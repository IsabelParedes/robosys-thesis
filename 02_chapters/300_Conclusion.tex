\chapter{Discussion}

This project set off to demonstrate the potential of running \ac{ROS} 2 on the browser by using WebAssembly. The proposed solution was subdivided into three major components: the creation of a custom middleware implementation, a method for cross-compiling \ac{ROS} 2 packages to WebAssembly, and the deployment of a web-based platform to offer users an opportunity to interact with \ac{ROS}.

The design of a custom middleware implementation, \textsf{rmw-wasm}, has been described in Chapter~\ref{cha:rmw}. \textsf{rmw-wasm} is composed of three distinct packages: \textsf{rmw-wasm-cpp}, \textsf{wasm-cpp}, and \textsf{wasm-cpp}. The interface between \ac{ROS} and the custom middleware implementation is carried out by \textsf{rmw-wasm-cpp}. The bridge between C++ and JavaScript is managed by \textsf{wasm-cpp}. And \textsf{wasm-js} handles the traffic of all \ac{ROS} participants and communications on the browser.

Two methods were developed to simplify the cross-compilation of \ac{ROS} 2 packages to WebAssembly. The simplest of the two involves using the GitHub workflow given in Appendix~\ref{sec:apxworkflow}. Running the GitHub workflow does not require the installation of any tools locally. The only optional requirement for the workflow is to provide a package to be cross-compiled; however, if the target package is already included in the core \ac{ROS} packages, then providing the name of the package as an input to the workflow is sufficient. The second method for building packages is more complicated because it requires a local setup. This second method uses the \textsf{blasm.sh} script given in Appendix~\ref{sec:apxblasm} but in order for the script to run properly, Emscripten, the \textsf{colcon} tools, CMake, Python, and a few additional dependencies must be pre-installed in the build environment. The procedure for building packages locally follows the same steps as those listed in the GitHub workflow, the only difference is that the workflow is automated.

A website was deployed to make the demonstrations described in Chapter~\ref{cha:assessment} available to the general public. The website can be accessed through this link: \href{https://ros2wasm.dev/}{https://ros2wasm.dev/}. The provided demonstrations range in user interaction level, from non-interactive ($\mathcal{I}1$) to intermediate ($\mathcal{I}4$), and from complexity level $\mathcal{C}1$ through $\mathcal{C}5$. The demonstrations show that multiple \ac{ROS} nodes can be run on the browser and that these nodes are capable of communicating with each other. A website running a particular set of nodes can easily be shared with other users with a link, however, the process of setting up such website has not yet been simplified enough for beginners. 

In summary, this project accomplish the goal of setting the foundation for a web-based \ac{ROS} 2 environment. The work completed made it possible for any user, from beginner to expert, to access a website and run \ac{ROS} nodes on the browser without any need to install any packages or have any knowledge of \ac{ROS} in the first place. It is also clear that more developments will need to be made, starting with the incomplete levels $\mathcal{C}6-\mathcal{C}9$ and $\mathcal{I}5-\mathcal{I}6$, before this project becomes a viable alternative to a native \ac{ROS} 2 installation.


\section{Outlook}

- JupyterLite
- client library
- Zethus and visualizations
- Message conversion
- Compiling on the browser
- Packaging Gazebo
- Optimization
- actions