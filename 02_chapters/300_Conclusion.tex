\chapter{Discussion}

This project set off to demonstrate the potential of running \ac{ROS} 2 on the browser by using WebAssembly. The proposed solution was subdivided into three major components: the creation of a custom middleware implementation, a method for cross-compiling \ac{ROS} 2 packages to WebAssembly, and the deployment of a web-based platform to offer users an opportunity to interact with \ac{ROS}.

The design of a custom middleware implementation, \textsf{rmw-wasm}, has been described in Chapter~\ref{cha:rmw}. \textsf{rmw-wasm} is composed of three distinct packages: \textsf{rmw-wasm-cpp}, \textsf{wasm-cpp}, and \textsf{wasm-cpp}. The interface between \ac{ROS} and the custom middleware implementation is carried out by \textsf{rmw-wasm-cpp}. The bridge between C++ and JavaScript is managed by \textsf{wasm-cpp}. And \textsf{wasm-js} handles the traffic of all \ac{ROS} participants and communications on the browser.

Two methods were developed to simplify the cross-compilation of \ac{ROS} 2 packages to WebAssembly. The simplest of the two involves using the GitHub workflow given in Appendix~\ref{sec:apxworkflow}. Running the GitHub workflow does not require the installation of any tools locally. The only optional requirement for the workflow is to provide a package to be cross-compiled; however, if the target package is already included in the core \ac{ROS} packages, then providing the name of the package as an input to the workflow is sufficient. The second method for building packages is more complicated because it requires a local setup. This second method uses the \textsf{blasm.sh} script given in Appendix~\ref{sec:apxblasm} but in order for the script to run properly, Emscripten, the \textsf{colcon} tools, CMake, Python, and a few additional dependencies must be pre-installed in the build environment. The procedure for building packages locally follows the same steps as those listed in the GitHub workflow, the only difference is that the workflow is automated.

A website was deployed to make the demonstrations described in Chapter~\ref{cha:assessment} available to the general public. The website can be accessed through the following link: \href{https://ros2wasm.dev/}{https://ros2wasm.dev/}. The provided demonstrations range in user interaction level, from non-interactive ($\mathcal{I}1$) to intermediate ($\mathcal{I}4$), and from complexity level $\mathcal{C}1$ through $\mathcal{C}5$. The demonstrations show that multiple \ac{ROS} nodes can be run on the browser and that these nodes are capable of communicating with each other. A website running a particular set of nodes can easily be shared with other users through a link, however, the process of setting up such website has not yet been simplified enough for beginners. 

In summary, this project accomplished the goal of setting the foundation for a web-based \ac{ROS} 2 environment. The work completed made it possible for any user, from beginner to expert, to access a website and run \ac{ROS} nodes on the browser without any need to install any packages or have any knowledge of \ac{ROS} in the first place. It is also clear that more developments will need to be made, starting with the incomplete levels $\mathcal{C}6-\mathcal{C}9$ and $\mathcal{I}5-\mathcal{I}6$, before this project becomes a viable alternative to a native \ac{ROS} 2 installation.


\section{Outlook}

The future work for this project can be dramatically expanded as it merges into the open-source \ac{ROS} ecosystem maintained by the community. As it stands, the author will continue the layered progression of the project until a minimum viable product is born. With that in mind, one of the most pressing upgrades to the current development will be adding support for a \ac{ROS} client library on the browser. 

The plan is to explore alternative methods for cross-compiling \textsf{rclpy} to make Python support available for beginners. And also to experiment with \textsf{roslibjs} since this JavaScript \ac{API} would fit perfectly with \textsf{wasm-js}. Once a client library becomes available, integration with JupyterLite will be straight forward because JupyterLite already has kernels for both Python and JavaScript.

If \textsf{roslibjs} does not present unsolvable issues when interacting with \textsf{rmw-wasm}, this will create a shortcut for integrating visualizations with Zethus. The visualization objects in Zethus come from Amphion which in turn uses \textsf{roslibjs} to retrieve visualization data from \ac{ROS} messages. 

Apart from client libraries, there are small but necessary tasks which still require implementation. One of these would be to enable changes in the log level. Currently, all of the \textsf{rmw-wasm} functions have debugging messages to trace function calls; however, none of these messages are displayed on the browser because the browser cannot change the logging level to debug mode. A workaround is to manually change the debug messages to warnings, but this is not the desired outcome. A better solution will be to implement a mechanism which allows changes in the logging levels from the browser, this would greatly reduce debugging time when compiling fresh nodes.

Another feature which is not urgently necessary but can currently be implemented would be the addition of action servers and action clients. These participants behave almost identically to service servers and clients but with the additional step that the action server provides feedback while it is processing a goal, and the action client can cancel the goal at any point.

As it may have been observed, there have been no attempts to optimize any of the elements from \textsf{rmw-wasm}. One area which could benefit from optimizations is the message conversion flow. Currently, messages undergo a minimum of two conversions, from \ac{ROS} message to \ac{YAML} string and in reverse. Additionally, these \ac{YAML} strings are later converted to \ac{JSON} objects. This complexity is unnecessary and it costs time. One solution would be to replace \textsf{dynmsg} with a package that can convert \ac{ROS} messages directly to \ac{JSON} objects and vice versa; this would eliminate the need for \ac{YAML} strings. Another solution would be to explore if type conversion is necessary at all, or if \ac{ROS} messages can be sent and returned from \textsf{wasm-js} in their original format.

A few of the tasks which lie farther down the path include: porting the \textsf{jupyter-ros} and \textsf{jupyterlab-ros} extensions to JupyterLite, creating a Gazebo Web extension for JupyterLite, and adding cross-compilation tools specifically for \ac{ROS} 2 to the browser.

It is also a goal for this project to attract more users and contributors. Having more users can easily expose all of the flaws in the project which make it ideal for continuous maintenance. And having more contributors significantly shortens the development process.
